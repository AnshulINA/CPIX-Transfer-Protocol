<pre class="metadata">
Date: 2018-04-01
Revision: 0.1

Title: DASH-IF Implementation Guidelines: Content Protection Information Exchange Format Transfer Protocol (CPIX-TP)
Status: LD
Shortname: cpix-tp
URL: https://dashif.org/guidelines/
Issue Tracking: GitHub https://github.com/Dash-Industry-Forum/CPIX-Transfer-Protocol/issues
Repository: https://github.com/Dash-Industry-Forum/CPIX-Transfer-Protocol GitHub
Editor: DASH-IF IOP, Content Protection and Security task force

Default Highlight: text
Line Numbers: on
Markup Shorthands: markdown yes
Boilerplate: copyright off, abstract off
Abstract: None
</pre>

<pre class="biblio">
{
	"DASH-CPIX": {
		"href": "https://dashif.org/guidelines/",
		"title": "DASH-IF Implementation Guidelines: Content Protection Information Exchange Format (CPIX)",
		"publisher": "DASH Industry Forum"
	},
	"DASH-IF-IOP": {
		"href": "https://dashif.org/guidelines/",
		"title": "Guidelines for Implementation: DASH-IF Interoperability Points, version 4.1, September 2017.",
		"publisher": "DASH Industry Forum"
	},
	"DASH-SystemIDs": {
		"href": "https://dashif.org/identifiers/protection/",
		"title": "DASH-IF registry of DRM System IDs.",
		"publisher": "DASH Industry Forum"
	},
	"RFC7231": {
		"href": "https://tools.ietf.org/html/rfc7231#section-6",
		"title": "Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content",
		"publisher": "Internet Engineering Task Force (IETF)"
	}
}
</pre>

<pre boilerplate="conformance">
<!-- This disables the RFC2119 conformance section, as we use custom DASH-IF specific text for this.  -->
</pre>

<pre boilerplate="logo">
<a href="https://dashif.org/"><img src="DASH-IF.png" /></a>
</pre>

# Scope # {#scope}

The scope of this document is to define a transfer protocol for [[!DASH-CPIX]]. [[!DASH-CPIX]] defines a XML container but is not providing instruction on how to reach conformity between different entities involved in a message exchange. Transfer protocol describes several use cases and integration patterns.

# Disclaimer # {#disclaimer}

This is a document made available by DASH-IF.  The technology embodied in this document may involve the use of intellectual property rights, including patents and patent applications owned or controlled by any of the authors or developers of this document. No patent license, either implied or express, is granted to you by this document. DASH-IF has made no search or investigation for such rights and DASH-IF disclaims any duty to do so. The rights and obligations which apply to DASH-IF documents, as such rights and obligations are set forth and defined in the DASH-IF Bylaws and IPR Policy including, but not limited to, patent and other intellectual property license rights and obligations. A copy of the DASH-IF Bylaws and IPR Policy can be obtained at http://dashif.org/.

The material contained herein is provided on an AS IS basis and to the maximum extent permitted by applicable law, this material is provided AS IS, and the authors and developers of this material and DASH-IF hereby disclaim all other warranties and conditions, either express, implied or statutory, including, but not limited to, any (if any) implied warranties, duties or conditions of merchantability, of fitness for a particular purpose, of accuracy or completeness of responses, of workmanlike effort, and of lack of negligence.

In addition, this document may include references to documents and/or technologies controlled by third parties.  Those third party documents and technologies may be subject to third party rules and licensing terms.  No intellectual property license, either implied or express, to any third party material is granted to you by this document or DASH-IF.  DASH-IF makes no any warranty whatsoever for such third party material.

# Introduction # {#main-intro}

CPIX defined in [[!DASH-CPIX]] is a container for Content Keys and DRM Signaling. It enables entities to exchange this data. [[!DASH-CPIX]] describes several use case where such exchanges are required but it does not define a transfer protocol. This document focuses on some of these use cases and define a transfer protocol. 

## Normative Language ## {#intro-conformance}

See [[!DASH-IF-IOP]] section 2.3.

## Terms and Definitions ## {#intro-terms}

See [[!DASH-CPIX]] section 3.2.

# Packager <-> DRM Server # {#packager-drm-server}

## Workflow ## {#packager-drm-server-workflow}

This is a basis workflow that is widely deploy. It consists in a Packager creating Content protected by several DRM Systems. As an example, a request from a user triggers an on the fly encryption and protection of an Asset with some DRM Systems.

<figure>
	<img src="packager-drm-system-exchange.png" />
	<figcaption>Example of Packager <-> DRM Server Content Key(s) and DRM Signalisation exchange flow.</figcaption>
</figure>

The above figure shows the exchange process between these two components. the responsibilities of each system are described below. This is an example, and some variation are possible, for example, Content Keys may already exist, hence it is not needed to create them every time.

1. The Packager encrypts the Assets, it needs some Content Key(s) and Content Protection data. 
2. The Packager creates a CPIX request indicating the number of Content Keys it needs and which DRM Systems are to be used (allowing to generate the right DRM Signaling). In the above example, the Packager requests one Content Key and one DRM System is used.
3. The Packager sends the CPIX message to the DRM Server. 
4. The DRM Server processes and updates the CPIX document
    1. It generates or registers the Content Key(s).
    2. It generates the requested DRM Signaling (can be for DASH, meaning the ContentProtection or/and PSSH data).
    3. It updates accordingly the CPIX document.
5. The DRM Server returns the updated CPIX document to the Packager.

For this exchange to be done, blablabla

## CPIX Elements ## {#packager-drm-server-cpix-elements}

In this context, not all elements of the CPIX document are needed, some optional elements are not used. At the root level of the document, the following lists are not used:
* <dfn element>DeliveryDataList</dfn>: It is assumed that the exchange is made using a pre-established trust between the Packager and the DRM Server. A classical deplyoment is for a TV operator where all entities are known. 
* <dfn element>UpdateHistoryItemList</dfn>: The flow does not require tracking the entotoes that made modification to the CPIX document, as it is a simple send/receive exchange.
* <dfn element>Signature</dfn>: The CPIX document is not signed.

For the other lists at the root level of the document, the following described in the next sections apply.

### <dfn element>ContentKeyList</dfn> Element ### {#packager-drm-server-contentKeyList}

A request for Content Keys must include empty elements for indicating the number of request keys and their specificies. If able to generate Content Keys, the receiving system fill the missing parts. Under this list the following elements can be provided empty in a request and the receiving entity is expected to complete the missing information:
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx

As an example, this is a request for two content keys identified by their kid, each one is having a defined usage rule.

```xml
<cpix:CPIX id="content1"  xmlns:cpix="urn:dashif:org:cpix">
    <cpix:ContentKeyList>
        <cpix:ContentKey kid="36a9ae27-144a-4d84-8747-a21ec817c1e9">
        </cpix:ContentKey>
        <cpix:ContentKey kid="c2910a53-817f-4d0e-ae5e-120fd25d242b">
        </cpix:ContentKey>
    </cpix:ContentKeyList>
    <cpix:ContentKeyUsageRuleList>
        <cpix:ContentKeyUsageRule kid="36a9ae27-144a-4d84-8747-a21ec817c1e9" intendedTrackType="sd+hd" />
        <cpix:ContentKeyUsageRule kid="c2910a53-817f-4d0e-ae5e-120fd25d242b" intendedTrackType="uhd" />
    </cpix:ContentKeyUsageRuleList>
</cpix:CPIX>
```

### <dfn element>DRMSystemList</dfn> Element ### {#packager-drm-server-drmSystemList}

A request for DRM Signaling (such as `PSSH`, `HLSSignalingData` ...) must include empty elements for indicating the number of requested DRM Signaling. If able to generate these, the receiving system fill the missing parts. Under this list the following elements can be provided empty in a request and the receiving entity is expected to complete the missing information:
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx

As an example, this is a request for both *PSSH* and *HLSSignalingData* for one DRM System (PlayReady).

```xml
<cpix:CPIX id="content1" xmlns:cpix="urn:dashif:org:cpix">
    <!-- ContentKeyList -->
    <cpix:DRMSystemList>
        <!-- playready -->
        <cpix:DRMSystem kid="36a9ae27-144a-4d84-8747-a21ec817c1e9" systemId="9a04f079-9840-4286-ab92-e65be0885f95">
            <cpix:PSSH></cpix:PSSH>
            <cpix:HLSSignalingData></cpix:HLSSignalingData>
        </cpix:DRMSystem>
    </cpix:DRMSystemList>
</cpix:CPIX>
```

### <dfn element>ContentKeyPeriodList</dfn> Element ### {#packager-drm-server-contentKeyPeriodList}

The presence of this list is driven by the existence of a `ContentKeyUsageRule` element referencing a `ContentKeyPeriod` element that would be part of this list.

### <dfn element>ContentKeyUsageRuleList ### {#packager-drm-server-contentKeyUsageRuleList}

This list can be added in a CPIX document either in a request or in a response. Its presence is driven by different elements, such as predefined rules (could be static), use of key rotation ... Under this list the following elements can be provided empty in a request and the receiving entity is expected to complete the missing information:
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx

As an example, this is a request where the receiving entity has to add values under the `KeyPeriodFilter` and `VideoFilter` elements. As a consequence, the answer will contain a `ContentKeyPeriodList` element.

```xml
<cpix:CPIX  xmlns:cpix="urn:dashif:org:cpix">
    <cpix:ContentKeyList>
        <cpix:ContentKey kid="36a9ae27-144a-4d84-8747-a21ec817c1e9">
        </cpix:ContentKey>
    </cpix:ContentKeyList>
    <cpix:ContentKeyUsageRuleList>
        <cpix:ContentKeyUsageRule kid="36a9ae27-144a-4d84-8747-a21ec817c1e9">
            <cpix:KeyPeriodFilter></cpix:KeyPeriodFilter>
            <cpix:VideoFilter></cpix:VideoFilter>
        </cpix:ContentKeyUsageRule>
</cpix:CPIX>
```

## Transfer Protocol ## {#packager-drm-server-transfer-protocol}

### Flow ### {#packager-drm-server-flow}

The flow uses an incremental update of the CPIX document. One entity generates a partial CPIX document following the rules defined in [[#packager-drm-server-cpix-elements]], and another entity completes it. As an example, a Packager will generate a document with empty Content Key(s) and empty DRM Signaling. The DRM Server adds Content Key(s) and DRM Signaling.

### Service API ### {#packager-drm-server-api-examples}

The preferred method of exchanging CPIX documents between entities is through a RESTful API.
The API allows ingesting, generating, retrieving and removing Content Key(s) for a `contentId` (attribute of the CPIX element). It is designed in accordance with the REST principles where interaction is based on resource entities. The parent resource for CPIX is the `contentId`.

The copyProtectionData endpoint exposes the API to consumers.

#### Headers #### {#packager-drm-server-api-headers}
Supported version of CPIX is signaled in Content-Type and Accept header as:

**Content-Type:** application/cpix+xml;version=2.1 <br/>
**Accept:** application/cpix+xml;version=2.1

#### POST #### {#packager-drm-server-api-post}
`POST {serviceUrl}/contents/{contentId}/copyProtectionData `

**Body:** CPIX object <br/>
Create CPIX object for an encryptor. <br/>
Encryptor (Packager Interface) will create CPIX request inserting empty elements in places when it expects a response to be provided. <br/>
**Response:** Filled CPIX object and HTTP 200 OK. <br/>

#### GET #### {#packager-drm-server-api-get}
`GET {serviceUrl}/contents/{contentId}/copyProtectionData `

**Body:** None <br/>
Return CPIX object for the referenced contentId. <br/>
**Response:** Filled CPIX object and HTTP 200 OK. <br/>

#### GET #### {#packager-drm-server-api-get-kid}
`GET {serviceUrl}/contents/{contentId}/copyProtectionData?kid={kid} `

**Body:** None <br/>
Return CPIX object for the referenced contentId and kid (Content Key Id). <br/>
**Response:** Filled CPIX object and HTTP 200 OK. <br/>

#### PUT #### {#packager-drm-server-api-put}
`PUT {serviceUrl}/contents/{contentId}/copyProtectionData ### {#api-put} `

**Body:** CPIX object <br/>
Update CPIX object referenced by the contentId <br/>
**Response:** Filled CPIX object and HTTP 200 OK. <br/>

#### DELETE #### {#packager-drm-server-api-delete}
`DELETE {serviceUrl}/contents/{contentId}/copyProtectionData  `

**Body:** None <br/>
Delete/purge all content keys for given contenId <br/>
**Response:** Filled CPIX object and HTTP 200 OK. <br/>

#### DELETE #### {#packager-drm-server-api-delete-kid}
`DELETE {serviceUrl}/contents/{contentId}/copyProtectionData?kid={kid} `

**Body:** None <br/>
Delete/purge content key for given contenId and kid (Content Key Id). <br/>
**Response:** Filled CPIX object and HTTP 200 OK. <br/>

### Error codes ### {#packager-drm-server-error-codes}

Implementation shall use the Response Status Codes defined below, that is a limited list from the one defined in [[!RFC7231]] section 6.

<table class="def">
	<tr>
		<th>Code</th>
		<th>Description</th>
	</tr>
	<tr>
		<td>200</td>
		<td>**OK** - The request has succeeded. Client can read result in the body and headers of the response.</td>
	</tr>
	<tr>
		<td>400</td>
		<td>**Bad Request** - The request could not be understood by the server due to malformed syntax or invalid data in the body. Body should contain additional details.</td>
	</tr>
	<tr>
		<td>401</td>
		<td>**Unauthorized** - The request requires user authentication or provided credentials are not valid.</td>
	</tr>
	<tr>
		<td>403</td>
		<td>**Forbidden** - The server understood the request, but is refusing to fulfill it. Server may describe reason for the refusal if it's not exposing server security.</td>
	</tr>
	<tr>
		<td>404</td>
		<td>**Not Found** - The requested resource identified by the URL could not be found. Can be temporary or permanent.</td>
	</tr>
	<tr>
		<td>405</td>
		<td>**Method Not Allowed** - Method specified in the Request in not allowed for the current resource.</td>
	</tr>
	<tr>
		<td>409</td>
		<td>**Conflict** - Request cannot be competed due to the conflict in the current state of the resource. The response body should include enough information for the user to recognize the source of the conflict and resolve it with the new request.</td>
	</tr>
	<tr>
		<td>415</td>
		<td>**Unsupported Media Type** - The body request is not compliant with the media type supported by the REST endpoint.</td>
	</tr>
	<tr>
		<td>429</td>
		<td>**Too Many Requests** - The user has sent too many requests in a given amount of time. Rate limiting has been applied.</td>
	</tr>
	<tr>
		<td>500</td>
		<td>**Internal Server Error** - Generic server error message. Client should not seen error with this error code. If it's the case issue should be raised and error should be handled with proper error code.</td>
	</tr>
	<tr>
		<td>503</td>
		<td>**Service Unavailable** - The server is currently unavailable and cannot handle request. Temporary condition. Query can be repeated again.</td>
	</tr>
</table>

## Implementation Example ## {#inline-examples}

In the example, the following is assumed. 
The Packager is capable of:
* Generating and requesting Content Keys
* requesting DRM Signaling
* Providing additional Content Key attributes that are crypto periods and track type (uhd, hd, sd, audio, text, data)
* Specifying Content Key usage rules (presumably defined by a Content Owner)

The DRM Server is capable of:
* Generating Content Keys
* Generating DRM Signaling

### Encoder Request ### {#packager-request-example}

```xml
POST [BaseURL]/contents/{contentId}/copyProtectionData
Content-Type: application/cpix+xml;version=2.1
Accept: application/cpix+xml;version=2.1

<cpix:CPIX id="content1"  xmlns:cpix="urn:dashif:org:cpix">
    <cpix:ContentKeyList>
        <cpix:ContentKey kid="36a9ae27-144a-4d84-8747-a21ec817c1e9">
        </cpix:ContentKey>
    </cpix:ContentKeyList>
    <cpix:DRMSystemList>
        <!-- playready -->
        <cpix:DRMSystem kid="36a9ae27-144a-4d84-8747-a21ec817c1e9" systemId="9a04f079-9840-4286-ab92-e65be0885f95">
            <cpix:PSSH></cpix:PSSH>
        </cpix:DRMSystem>
    </cpix:DRMSystemList>
</cpix:CPIX>
```

### DRM System Response ### {#drm-response-example}

```xml
HTTP/1.1 200 OK
Content-Type: application/cpix+xml;version=2.1
 
<cpix:CPIX id="content1"  xmlns:cpix="urn:dashif:org:cpix">
    <cpix:ContentKeyList>
        <cpix:ContentKey kid="36a9ae27-144a-4d84-8747-a21ec817c1e9">
            <cpix:Data>
                <pskc:Secret>
                    <pskc:PlainValue>Pie+RqjjZ9XF+YFR83A06w==</pskc:PlainValue>
                </pskc:Secret>
            </cpix:Data>
        </cpix:ContentKey>
    </cpix:ContentKeyList>
    <cpix:DRMSystemList>
        <!-- playready -->
        <cpix:DRMSystem kid="36a9ae27-144a-4d84-8747-a21ec817c1e9" systemId="9a04f079-9840-4286-ab92-e65be0885f95">
            <cpix:PSSH>===Base64 of PSSH for PlayReady===</cpix:PSSH>
        </cpix:DRMSystem>
    </cpix:DRMSystemList>
</cpix:CPIX>
```

## Examples Files ## {#examples}

The follwing CPIX document are made available.

### VOD Single Key ### {#examples-vod-single-key}

A Packager is encrypting a VOD asset where all tracks (audio, sd, hd) are encrypted with the key 36a9ae27-144a-4d84-8747-a21ec817c1e9. The Packager is not able to provide additional information about tracks to a DRM Server.

### VOD Multi Track With Multiple Keys ### {#examples-vod-multiple-keys}

A Packager is encrypting a VOD asset where some tracks (audio, sd) are encrypted with the key 36a9ae27-144a-4d84-8747-a21ec817c1e9 while all others tracks (hd, uhd) are encrypted with the key c2910a53-817f-4d0e-ae5e-120fd25d242b.

### Live Multiple Crypto-periods With a Single Key Per Track ### {#examples-live-periods}

A Packager is encrypting a Live stream where all tracks are encrypted with the same key on a given crypto-period. The packager requests three crypto-periods in one request and is not providing additional information about tracks to a DRM Server.